## [15.1.3] - 2025-06-11

### ðŸ’¼ Other

- Added support for stopping the reactivity by calling #dispose on the observable
- Fixed a typo
- Ensuring it also recognizes instances of the Observable class
- Marked the call method as private
- Avoiding setting a noop disposer at all
- Making the "computed" class method return another class
- More cleanly separated private and public methods
- Using an array instead of a set for storing the listeners, for better memory usage
- Avoiding creating the listeners array if not needed
- Using arrays instead of sets for storing links
- Using an array instead of a set for storing listeners
- Avoiding calling a noop cleanup function unnecessarily
- Improved check
- Updated call method's type
- Added a little table of contents
- Returning a read-only observable, at least as a type-level constrain
- Getting recursively if possible
- Minor optimization when a cleanup function is returned
- Changed API to allow for overriding outer contexts
- Returning a disposer function
- Ensuring the proper return type is returned
- Keeping observers in a Set rather than an Array for better performance guarantees
- Deleted wrapVoid function
- Deleted wrapWithout function
- Avoiding triggering an unsubscription during the first execution
- Accessing the observable value directly, bypassing the "sample" function
- Avoiding resolving observables recursively, as that's largely unnecessary and it can't be typed properly
- Removed "on" method
- Optimized emission when the set contains only one observer
- Cleaning up properties in a more efficient way
- Replaced a forEach with a for loop
- Optimized observable registration, skipping the `has` check
- Added a test about errors being thrown if triggered inside the error handler
- Added tests about errors being thrown if triggered inside the error handler inside effects or roots
- Changed return type to not account for edge cases undefined, for convenience
- Checking for readable and writable observables more strictly
- Avoiding wrapping the effect, creating it directly
- Updated $.effect description
- Removed an unnecessary function call when setting a value
- Fixed a bug where potential sets where treated like potential arrays
- Ensuring a default value of the "active" property is set
- Added a 500000 run
- Renamed a variable
- Soft-deleting observers and deleting them at emission time, as a performance optimization
- Avoiding scheduling microtasks on cleanup, as that probably ends up being more expensive
- Registering cleanups slightly more efficiently
- Avoiding automatically disposing of useless effects, trading some memory for some more performance
- Delete all internal observables at once on cleanup
- Avoiding deleting observers immediately as long as they get disposed, marking instead observers themselves as deleted
- Ensuring the value can be also set to undefined
- Ensuring they register themselves only once
- Deleted a useless function body
- Slightly optimized emission
- Added a "dispose" method to selectors, for some extra opt-in performance
- Slightly optimized self registration
- Fixed a typo
- Disposing of known observables when disposing too
- Returning the value returned by the function passed to it
- Automatically disposing of useless ones again
- Ensuring useless ones are unregistered from their owners too, to free up some memory
- Calling computeds before effects whenever possible
- Always forcing a refresh of the parent computed when needed, for extra safety
- Deleted "dirty" property
- Removed support for manual disposition
- Avoiding exposing "dispose" and "isDisposed" APIs
- Deleted, as it no longer enables the optimization I implemented it for
- Unified staleCount and staleFresh into a single number
- Ensuring it can handle the case where its own observable is disposed before it can return
- Skipping updates early if its own observable got disposed
- Disposing of its observable when disposing of the computed itself
- Automatically disposing of useless ones
- Ensuring it disposes of its own observable when disposing of itself
- Optimized the edge case where a disposed observable is passed to the selector
- Optimized memory usage of observables having only one observer
- Optimized memory usage for array internal properties
- Avoiding refreshing when nothing could/should have possibly changed
- Added back a 5000 layers test case
- Ensuring the number of layers is always passed on as a number
- Optimized memory usage somewhat
- Optimized memory usage somewhat
- Fixed an issue where a computed causing itself to re-execute caused an old value to be the last value set
- Deleted emit method, too much of a footgun
- Added support for a "false" equality function, which always causes the observable to emit even if nothing changed when setting
- Renamed "select" method to "computed", for better clarity
- Replaced roots with plain observers internally, which are a bit cheaper to make
- Avoiding traversing old observers on postdispose, which was entirely useless
- Ensuring the produce method can be wired with immer or something else
- Checking that the return value is actually a function, for extra safety
- Accepting conditions of any type
- Accepting conditions of any type
- Added support for returning a fallback value for an empty array of values
- Renamed an internal variable for consistency
- Added a fallback value for falsy conditions
- Ensuring update functions are detected properly
- Ensuring values are resolved only once if the condition changes but the result value is the same
- Updated
- Ensuring the interface for $.batch is mentioned too
- Simplified caching disposition logic a bit
- Using a proper root, which ensures errors bubble up properly
- Ensuring they can't execute multiple times simultaneously, and delete reliance on always-incrementing internal counters
- Ensuring the provided types are mentioned too
- Ensuring it doesn't turn sampling on inside nested observers too
- Added a unique symbol to its type, ensuring TS can tell these apart from regular functions
- Improved return type
- Returning "any", sadly, because returning the proper type can just trigger TS infinite loop detection down the line
- Added support for being called with non-functions and returning them unchanged, for convenience
- Updated section for $.sample
- Reimplemented in terms of $.switch
- Added support for passing a non-function to it, which just gets returned as is, for convenience
- Improved interface
- Slightly cleaner implementation
- Improved interface
- Improved public interface
- Updated root's interface
- Slightly cleaner implementation
- Rewritten to work like this: it basically just replaces each function it finds with a computed that calls that function
- Added a couple of tests regarding disposal
- Updated with the new $.resolve
- Added some notes
- Ensuring they don't override the sampling status outside of their scope
- Added a test
- Avoiding setting the parent as undefined explicitly
- Freeing up some memory and returning a cheaper read-only observable if the computed can never be executed again
- Freeing up some memory if the effect can never possibly run again
- Removed support for calling the passed function with the previous result
- Slightly optimized array resolution
- Storing mapped items in a bit less memory
- Storing internal observables in a bit less memory
- Storing mapped items in a bit less memory
- Updated repository url
- Ensuring that if multiple observables are updated whitin itself they still trigger one update of for computeds/effects, even if they listened to many of those observables
- Optimized batches affecting less than 2 observables
- Simplified implementation
- Simplified implementation
- Significantly optimized writes of non-fresh value for standalone observables
- Keeping track of the current root signal as well, optimizing some things a bit more
- Lowered memory usage by a third
- Ensuring internal observables inherit the abort signal available at the time when the selector was created
- Rewritten to instead be a mechanism for suspending the execution of effects inside it
- Using the existent observers tree, rather than keeping track of effects again
- Ensuring it can handle lazily-created effects and suspenses
- Added a fast path for when this method is never called
- Optimizated condition conversion to boolean
- Simplified implementation
- Ensuring context can be read through suspense
- Set ES2018 as the target
- Diffing the previous set of observables with the new one
- Avoiding unregistering from disposed observables
- Ensuring it can't cause the parent observer, the one being cleaned up, to be re-executed
- Improved tree-shaking
- Slightly cleaner implementation
- Broaded types to allow read-only arrays
- Ensuring the currently selected item is updated even inside suspense
- Ensuring it can pause effects created inside roots
- Ensuring it registers itself with the owner only if it could potentially be suspended
- Ensuring it registers and unregisters itself with the right owner
- Keeping track of roots in a lazy set
- More efficiently registering roots for suspense purposes
- Simplified a couple of methods, reusing lazySet* functions
- Throwing if they receive an async function, as that's most probably a mistake
- Improved section for $.context
- Added symbols for detecting the various kinds of observables: frozen/readable/writable
- Added support for returning the underlying instance when called with SYMBOL_OBSERVABLE (readable/writable)
- Returing the same observable if it's already read-only
- Avoiding leveraging a computed, which could enable some further optimizations in the future
- Added support for returning an observable rather than a raw value
- Avoiding caching readable observables, to enable them to get garbage collected
- Avoiding creating a cleanup function per call
- Added support for plain Observable classes, which enable an optimization under the hood in Voby
- Renamed an internal variable
- Always returning a read-only observable
- Deleted unused "is" method
- Calling listeners slightly more efficiently, as that's something heavily relied upon in Voby
- Added a comment
- Doing nothing when the current owner is the super owner
- Avoiding eargerly creating the properties map
- Ignoring assignments that override Array's methods
- Ensuring the references count is incremented and decremented properly
- Listening on read, and making the related observables, only if the current owner could listen to them
- Added a little benchmark
- Avoiding handling getters and setters in arrays
- Fixed a typo
- Detecting non-reactive keys more efficiently
- Widened type to allow for any function as the source, enabling support for stores
- Calling the map function with the index of the value too
- Calling the map function with an observable to the index of the value too
- Added a comment
- Ensuring mapping happens in a sample, to avoid potential unwanted suscriptions
- Improved support for stores, ensuring assignments at indexes are detected too
- Simplified some code
- Ensuring the listener is always called upon registration
- Added a comment
- Added support for arrays containing duplicates
- Added support for Object.defineProperty
- Returning a dispose function rather than nothing
- Checking for special symbols when getting in constant time
- Avoiding generating metadata for properties when that's not necessary in some cases, to save some memory
- Added an hacky way to extract observables out of stores, mostly useful for internal purposes
- Fixed an issue with the SYMBOL_STORE_OBSERVABLE symbol
- Returning a readable observable rather than a writable one when requesting one with the SYMBOL_STORE_OBSERVABLE symbol, for better consistency with getters
- Forbidding more properties from being reactive: `__defineGetter__`, `__defineSetter__`, `__lookupGetter__`, `__lookupSetter__`
- Fixed an issue with SYMBOL_STORE_OBSERVABLE
- Calling functions by defaults too, with an option for callign only observables
- Pre-creating the array of results with the right size
- Unified some internal implementation details under a single (unexposed) $.forAbstract
- Added a comment
- Updated description for $.get
- Simplified some code
- Fixed a bug where cleaning up everything would also unregister roots
- Fixed a typo
- Updated type to be easier to work with for TS, this should fix some issues with that
- Ensuring the reactivity is stopped immediately when going to an empty array of values
- Improved function signature
- Renamed to $.untrack -- SYMBOL_SAMPLED renamed to SYMBOL_UNTRACKED
- Renamed to $.memo
- Optimized creation, avoiding creating at most 2 memos per call if the when condition is static
- Added support for a "fallback" argument, for consistency
- Ensuring the fallback is reused when the values change but it's still an empty array
- Fixed a typo
- Minor changes
- Simplified wrap logic, simplifying untrack's implementation and avoiding traversing the prototype chain
- Simplified implementation, accepting always a function to batch
- Slightly simplified implementation
- Simplified implementation, allowing cleanups to be registered on the superroot too
- Renamed methods that read and write in the context
- Slightly cleaned up code
- Simplified implementation slightly
- Slightly cleaned up implementation
- Slightly cleaner formatting
- Simplified implementation
- Simplified implementation
- Simplified slightly
- Removed a superflous semicolon
- Generalized slightly, deleting $.suspendable
- Simplified implementation
- Simplified implementation
- Optimized performance when the parent computation is disposed
- Minor tweaks
- Moved unwrapping to a dedicated utility function: $.store.unwrap
- Minor tweaks and core re-organization
- Ensuring post-disposal observables deduplication never takes quadratic time
- Fixed an issue where the equality function was called for the first execution too, which was a mistake
- Using 10x the number of iterations, but fewer layers
- Avoiding throwing at runtime if an async function is passed, relying instead to types
- Added some missing semicolons
- Deleted a no-longer-needed comment
- Using a single number to keep track of all 3 status bits
- Worked around a TS issue
- Minor reorganization
- Ensuring the passed function never receives the dispose function coming from the parent, if it's a root
- Simplified listening observer detection
- Grouped tests for `$.store.unwrap` on their own
- Ensuring equivalent property descriptors set via Object.defineProperty are detected
- Deleted note comparing $.store with createMutable, as createMutable in more recent versions actually works like $.store
- A new utility method for listening to changes happening inside a section of a store
- A new utility method for fine-grainely updating a store with a new data object
- Ensuring that array pushes are not deduplicated, even if that's desirable potentially, as that's not how a push should work
- More reliably keeping track is listening is active or not
- Ensuring already traversed nodes are not traversed again when fiding event handlers, for better worst case scenario guarantees
- Added support for functions that return a promise, which are now awaited
- New method that tells you if currently batching or not
- Ensuring it waits for async batching to settle first
- Fixed a couple of typos
- Ensuring it always works with arbitrary functions
- Ensuring mutations that don't actually change anything don't trigger any listeners
- A new (work in progress) function for listening to changes in root properties specifically, for reacting to them very precisely
- Ensuring circular references are supported too
- Using a more consistent delay
- Ensuring it throws if a non-top-level store is passed on
- Simplified internal implementation slightly
- Simplified internal implementation slightly
- Freeing up memory when the function will never be executed again in more scenarios
- Just producing frozen observables if we are dealing with disposed ones, which can never change
- Freeing up memory when the function will never be executed again in more scenarios
- Improved wording
- Simplified implementation, and avoiding calling the listener immediately, which is more flexible
- Ensuring the source function is read only once
- Ensuring cleanup is optimized whenever the parent is disposed, even if it's not a root
- Improved performance by ~10% on average
- Improved performance by ~30% on average
- Ensuring the source function is memoized
- Using an internal symbol for enabling an optimization in Voby
- Optimized cleanup when new items are added to the array without removing any items
- Added support for proxying any object, if done explicitly
- Detecting getters and setters more memory efficiently
- Added a little benchmark measuring creation time
- Removed support for getters and setters assigned to symbols, as they are too much of a performance issue
- A new store utility for bailing out of automatic proxying
- Optimized duplicate registrations in some cases
- Ensuring the get trap exists right after listening to keys and values
- Automatically logging the stack of an uncaught error, for convenience
- Running the benchmark with tracking on
- Slightly simplified
- Checking for the specific symbols rather than the general one
- Removed a type assertion
- Slightly simplified setting the fresh bit
- Slightly simplified self-registration logic
- Simplified signal creation, no need to reference the root too
- Added support for setting a custom equality function
- Slightly optimized disposal, avoiding changing the shape of the object, without sacrificing memory usage for it
- Optimized the case where the source is a frozen observable
- Ensuring the source function is normalized to an observable, for better performance
- Ensuring it throws if used after being disposed
- Updated thanks section
- Avoiding automatically logging the stack of unhandled errors, as that's incorrect in some cases
- Ensuring it updates the length of top-level arrays also
- Added a fixme
- Ensuring it doesn't break reactivity
- Returning the same exact array of results if the mapped values stayed exactly the same
- Added cached/uncached metadata to the results array too, like $.for
- Added cached/uncached metadata to the results array too, like $.for
- Ensuring it keeps in memory one fewer memo when the condition is static
- Ensuring it accounts for changes in the sorting order of results
- Fixed a typo
- Fixed some typos
- Documented the "observable" function
- Marking it as disposed, and avoiding registering it as a dependency, when the parent memo, if any, will never be re-executed
- Considering disposed ones as frozen
- Optimized for static cases
- Optimized for a static source
- Slightly cleaner implementation
- Slightly optimized stale propagation
- Slightly cleaner implementation
- Added another tier of synchronousness, "init"
- Ensuring all queued effects get executed, even if scheduled while flushing
- Deduplicating dependencies exactly up to 64 dependencies
- Ensuring it doesn't dispose of pre-existing dependencies
- Ensuring it's attached to the default export also, for consistency
- Updated signature for $.batch
- Ensuring $.tick is documented
- Ensuring the disposal optimization is actually performed on effects
- Optimized re-execution, skippung unnecessary unscheduling
- Slightly optimized deduplication of observables
- Avoiding scheduling it if under a suspended suspense
- Ensuring dirty effects with sync: init are refreshed immediately too when the boundary unsuspends
- Added a "pooled" option for the unkeyed strategy
- Avoiding registering on the parent if the parent is the super root
- Added a "createComputations1to1" test
- Ensuring the disposal optimization doesn't cause erroneous over-executions in edge cases
- Always deduplicating observers exactly, as otherwise it's just buggy
- Optimized disposal when just replacing the last observable in the list with another
- Optimized slightly, mainly simplifying call stacks in some cases
- A new method that tells you if you are undera suspended computation or not
- Updated
- Optimized to create as few memos as possible, which sometimes mean 0 memos, rather than 2
- Rewritten to make lookups basically free, but the API for setting it is different now
- Updated
- Ensuring every case where the condition is not actually reactive and neither is the return value is optimized
- Updated
- Updated
- Updated
- A new method for creating an untracked function, in an optimized way
- Optimized for untracked functions, 7x faster for them
- Optimized for untracked functions, 4x faster for them
- Optimized for untracked functions and frozen observables, 4x faster for them
- Updated
- Ensuring it supports functions with arguments too
- Updated
- Optimized for frozen observables too
- Optimized for frozen observables too
- Simplified implementation
- Simplified and optimized
- Updated
- Updated example for $.with
- Updated
- Ensuring it gets disposed properly by its owner
- Ensuring effects created inside it can be suspended properly
- Updated
- Updated
- Updated
- Ensuring pooled results can work with a parent suspense boundary too
- Added support for making a synchronous one
- Avoiding mentioning the EqualsFunction internal type
- Fixed handling of changes in "in" checks when defining properties on the store
- Improved types, accounting for FunctionMaybe types explicitly, which TS seems to need
- Fixed an issue where setting a property pointing to a store with defineProperty set the store itself, rather than the object it points to
- Updated
- Fixed an issue with listening for top-level array stores
- Aded a warning about `$.store.unwrap`
- Fixed a typo
- Added support for receiving an undefined value, for convenience
- Optimized the scenario where the input function is an observable already by some 15%
- Reverted optimization because it could have some unexpected side effects
- Optimized some common cases, creating 1 fewer memo
- Added a fast path for plain arrays, where the index you receive is a raw number
- Updated types for $.for
- Optimized when used in combination with $.if, $.ternary and $.switch
- Fixed a typo
- Fixed a typo
- Ensuring frozen objects are returned as is, to respect a proxy trap invariant
- Ensuring non-configurable non-writable properties are returned as is, to respect a proxy trap invariant
- Ensuring the getter is not called when setting if there is no setter
- Ensuring hasOwnProperty calls are incercepted too
- Added a todo regarding handling Object.getOwnProperty maximally reactively
- Dropped support for intercepting getOwnPropertyDescriptor calls, as it has too many unintended side-effects
- Ensuring already proxied objects don't get reproxied, and their equality function is not overridden
- Added a currently skipped test for a dubious scenario
- Ensuring that when deleting a property the eventual getter and setter associated with it are fully forgotten
- Added a test to make sure getters are not accessed during "in" property checkes
- Added a currently skipped test for getters being defined on the prototype
- Ensuring properties implicitly deleted by shrinking an array are handled too
- Ensuring it reacts when the length property is updated implicitly
